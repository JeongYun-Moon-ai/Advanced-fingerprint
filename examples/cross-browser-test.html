<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Fingerprint Test</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #eee;
            padding: 1rem;
        }
        .container { max-width: 600px; margin: 0 auto; }
        h1 {
            text-align: center;
            font-size: 1.3rem;
            color: #00d9ff;
            margin-bottom: 0.3rem;
        }
        .subtitle {
            text-align: center;
            color: #888;
            font-size: 0.8rem;
            margin-bottom: 1.5rem;
        }
        .card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 1.2rem;
            margin-bottom: 1rem;
        }
        .card h2 {
            color: #00d9ff;
            font-size: 0.95rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .btn {
            background: linear-gradient(135deg, #00d9ff, #0099cc);
            border: none;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: #000;
            font-weight: 700;
            cursor: pointer;
            width: 100%;
            font-size: 1rem;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.98); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .hash-box {
            background: rgba(0,0,0,0.3);
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
            text-align: center;
        }
        .hash-label {
            color: #888;
            font-size: 0.7rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .hash-value {
            color: #00ff88;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.75rem;
            word-break: break-all;
            line-height: 1.4;
        }
        .accuracy-badge {
            display: inline-block;
            background: rgba(0,255,136,0.2);
            color: #00ff88;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 1.5rem;
            font-weight: 700;
            margin: 1rem 0;
        }
        .signals {
            margin-top: 1rem;
            font-size: 0.75rem;
        }
        .signals table {
            width: 100%;
            border-collapse: collapse;
        }
        .signals td {
            padding: 0.5rem 0.3rem;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .signals td:first-child {
            color: #888;
            width: 45%;
        }
        .signals td:last-child {
            color: #ddd;
            font-family: monospace;
            font-size: 0.7rem;
            word-break: break-all;
        }
        .loading {
            text-align: center;
            padding: 2rem;
            display: none;
        }
        .loading.active { display: block; }
        .spinner {
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #00d9ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .compare-section {
            background: rgba(255,200,0,0.1);
            border: 1px solid rgba(255,200,0,0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        .compare-section h3 {
            color: #ffc800;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }
        .compare-section input {
            width: 100%;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 0.8rem;
            color: #fff;
            font-family: monospace;
            font-size: 0.75rem;
        }
        .compare-section input:focus {
            outline: none;
            border-color: #ffc800;
        }
        .compare-result {
            margin-top: 0.8rem;
            padding: 0.8rem;
            border-radius: 6px;
            text-align: center;
            font-weight: 600;
        }
        .compare-result.match {
            background: rgba(0,255,136,0.2);
            color: #00ff88;
        }
        .compare-result.mismatch {
            background: rgba(255,80,80,0.2);
            color: #ff5050;
        }
        .info-box {
            background: rgba(0,217,255,0.1);
            border: 1px solid rgba(0,217,255,0.3);
            border-radius: 8px;
            padding: 1rem;
            font-size: 0.8rem;
            color: #aaa;
            line-height: 1.5;
        }
        .info-box strong { color: #00d9ff; }
        .copy-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            color: #fff;
            font-size: 0.75rem;
            cursor: pointer;
            margin-top: 0.5rem;
        }
        .copy-btn:active { background: rgba(255,255,255,0.2); }
    </style>
</head>
<body>
    <div class="container">
        <h1>Device Fingerprint</h1>
        <p class="subtitle">Hardware-based device identification</p>

        <div class="card">
            <div class="info-box">
                <strong>Test Method:</strong><br>
                1. Generate fingerprint here<br>
                2. Open same URL in Incognito/Private mode<br>
                3. Generate again - hash should be <strong>identical</strong>
            </div>
        </div>

        <div class="card">
            <h2>Generate Fingerprint</h2>
            <button class="btn" id="generateBtn">Generate Fingerprint</button>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Collecting hardware signals...</p>
            </div>

            <div id="result" style="display:none;">
                <div style="text-align:center;">
                    <div class="accuracy-badge" id="accuracyValue">0%</div>
                    <div style="color:#888;font-size:0.75rem;">Estimated Accuracy</div>
                </div>

                <div class="hash-box">
                    <div class="hash-label">Device Hash</div>
                    <div class="hash-value" id="hashValue">-</div>
                    <button class="copy-btn" id="copyBtn">Copy Hash</button>
                </div>
            </div>
        </div>

        <div class="card" id="signalsCard" style="display:none;">
            <h2>Hardware Signals</h2>
            <div class="signals">
                <table id="signalsTable"></table>
            </div>
        </div>

        <div class="card">
            <div class="compare-section">
                <h3>Compare Hash</h3>
                <p style="font-size:0.7rem;color:#888;margin-bottom:0.5rem;">
                    Paste hash from another browser/mode to compare:
                </p>
                <input type="text" id="compareInput" placeholder="Paste hash here...">
                <div id="compareResult" class="compare-result" style="display:none;"></div>
            </div>
        </div>
    </div>

    <script type="module">
        // ====== Utilities ======
        class FingerprintUtils {
            static async sha256(data) {
                const buffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(data));
                return Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
            }
        }

        // ====== Accuracy Weights ======
        const ACCURACY_WEIGHTS = {
            BASE: 0.05,
            GPU_RENDERER: 0.25,
            GPU_VENDOR: 0.05,
            SCREEN_RESOLUTION: 0.10,
            TIMEZONE: 0.08,
            HARDWARE_CONCURRENCY: 0.08,
            SHADER_PRECISION: 0.12,
            WEBGL_MAX_TEXTURE: 0.07,
            PLATFORM: 0.05,
            MAX_ACCURACY: 0.80,
        };

        // ====== Fingerprinter ======
        class Fingerprinter {
            async generate() {
                const webgl = this.analyzeWebGL();
                const webglInfo = this.getStableWebGLInfo();

                const signals = {
                    gpuRenderer: webgl.renderer || '',
                    gpuVendor: webgl.vendor || '',
                    screenResolution: `${screen.width}x${screen.height}`,
                    availableScreen: `${screen.availWidth}x${screen.availHeight}`,
                    pixelRatio: Math.round(window.devicePixelRatio * 100) / 100,
                    colorDepth: screen.colorDepth,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    hardwareConcurrency: navigator.hardwareConcurrency || 0,
                    maxTouchPoints: navigator.maxTouchPoints || 0,
                    platform: navigator.platform || '',
                    shaderPrecision: webglInfo.shaderPrecision,
                    webglMaxTextureSize: webglInfo.maxTextureSize,
                    webglMaxViewportDims: webglInfo.maxViewportDims,
                    webglExtensionCount: webglInfo.extensionCount,
                    webglMaxRenderbufferSize: webglInfo.maxRenderbufferSize,
                    webglMaxVertexAttribs: webglInfo.maxVertexAttribs,
                };

                const stableData = [
                    signals.gpuRenderer,
                    signals.gpuVendor,
                    signals.screenResolution,
                    signals.availableScreen,
                    signals.pixelRatio.toFixed(2),
                    signals.colorDepth,
                    signals.timezone,
                    signals.hardwareConcurrency,
                    signals.maxTouchPoints,
                    signals.platform,
                    signals.shaderPrecision,
                    signals.webglMaxTextureSize,
                    signals.webglMaxViewportDims,
                    signals.webglExtensionCount,
                    signals.webglMaxRenderbufferSize,
                    signals.webglMaxVertexAttribs,
                ].join('|');

                const hash = await FingerprintUtils.sha256(stableData);

                // Calculate accuracy
                const W = ACCURACY_WEIGHTS;
                let accuracy = W.BASE;
                if (signals.gpuRenderer) accuracy += W.GPU_RENDERER;
                if (signals.gpuVendor) accuracy += W.GPU_VENDOR;
                if (signals.screenResolution !== '0x0') accuracy += W.SCREEN_RESOLUTION;
                if (signals.timezone) accuracy += W.TIMEZONE;
                if (signals.hardwareConcurrency > 0) accuracy += W.HARDWARE_CONCURRENCY;
                if (signals.shaderPrecision) accuracy += W.SHADER_PRECISION;
                if (signals.webglMaxTextureSize > 0) accuracy += W.WEBGL_MAX_TEXTURE;
                if (signals.platform) accuracy += W.PLATFORM;
                accuracy = Math.min(accuracy, W.MAX_ACCURACY);

                return { hash, accuracy, signals };
            }

            analyzeWebGL() {
                const c = document.createElement('canvas');
                const gl = c.getContext('webgl') || c.getContext('experimental-webgl');
                if (!gl) return { vendor: '', renderer: '' };
                const d = gl.getExtension('WEBGL_debug_renderer_info');
                const vendor = d ? gl.getParameter(d.UNMASKED_VENDOR_WEBGL) : gl.getParameter(gl.VENDOR);
                const renderer = d ? gl.getParameter(d.UNMASKED_RENDERER_WEBGL) : gl.getParameter(gl.RENDERER);
                return { vendor, renderer };
            }

            getStableWebGLInfo() {
                const defaultValue = {
                    shaderPrecision: '',
                    maxTextureSize: 0,
                    maxViewportDims: '0,0',
                    extensionCount: 0,
                    maxRenderbufferSize: 0,
                    maxVertexAttribs: 0,
                };

                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') ?? canvas.getContext('experimental-webgl');
                    if (!gl) return defaultValue;

                    const precisions = [];
                    const shaderTypes = [gl.VERTEX_SHADER, gl.FRAGMENT_SHADER];
                    const precisionTypes = [gl.LOW_FLOAT, gl.MEDIUM_FLOAT, gl.HIGH_FLOAT];

                    for (const shaderType of shaderTypes) {
                        for (const precisionType of precisionTypes) {
                            const precision = gl.getShaderPrecisionFormat(shaderType, precisionType);
                            if (precision) {
                                precisions.push(`${precision.rangeMin}:${precision.rangeMax}:${precision.precision}`);
                            }
                        }
                    }

                    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE) || 0;
                    const maxViewportDims = gl.getParameter(gl.MAX_VIEWPORT_DIMS) || [0, 0];
                    const extensions = gl.getSupportedExtensions() || [];
                    const maxRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE) || 0;
                    const maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS) || 0;

                    return {
                        shaderPrecision: precisions.join('|'),
                        maxTextureSize,
                        maxViewportDims: `${maxViewportDims[0]},${maxViewportDims[1]}`,
                        extensionCount: extensions.length,
                        maxRenderbufferSize,
                        maxVertexAttribs,
                    };
                } catch {
                    return defaultValue;
                }
            }
        }

        // ====== UI ======
        const fp = new Fingerprinter();
        let currentHash = '';

        document.getElementById('generateBtn').onclick = async () => {
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('loading').classList.add('active');
            document.getElementById('result').style.display = 'none';
            document.getElementById('signalsCard').style.display = 'none';

            try {
                const result = await fp.generate();

                document.getElementById('hashValue').textContent = result.hash;
                document.getElementById('accuracyValue').textContent = (result.accuracy * 100).toFixed(0) + '%';

                currentHash = result.hash;

                // Signals table
                const table = document.getElementById('signalsTable');
                table.innerHTML = '';
                const signals = result.signals;
                const rows = [
                    ['GPU Renderer', signals.gpuRenderer || '(N/A)'],
                    ['GPU Vendor', signals.gpuVendor || '(N/A)'],
                    ['Screen', signals.screenResolution],
                    ['Available', signals.availableScreen],
                    ['Pixel Ratio', signals.pixelRatio],
                    ['Color Depth', signals.colorDepth],
                    ['Timezone', signals.timezone],
                    ['CPU Cores', signals.hardwareConcurrency],
                    ['Touch Points', signals.maxTouchPoints],
                    ['Platform', signals.platform],
                    ['Max Texture', signals.webglMaxTextureSize],
                    ['Max Viewport', signals.webglMaxViewportDims],
                    ['WebGL Ext.', signals.webglExtensionCount],
                ];

                for (const [label, value] of rows) {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${label}</td><td>${value}</td>`;
                    table.appendChild(tr);
                }

                document.getElementById('result').style.display = 'block';
                document.getElementById('signalsCard').style.display = 'block';
            } catch (e) {
                alert('Error: ' + e.message);
            }

            document.getElementById('loading').classList.remove('active');
            document.getElementById('generateBtn').disabled = false;
        };

        // Copy button
        document.getElementById('copyBtn').onclick = () => {
            navigator.clipboard.writeText(currentHash).then(() => {
                document.getElementById('copyBtn').textContent = 'Copied!';
                setTimeout(() => {
                    document.getElementById('copyBtn').textContent = 'Copy Hash';
                }, 2000);
            });
        };

        // Compare input
        document.getElementById('compareInput').addEventListener('input', (e) => {
            const inputHash = e.target.value.trim();
            const resultEl = document.getElementById('compareResult');

            if (!inputHash || !currentHash) {
                resultEl.style.display = 'none';
                return;
            }

            resultEl.style.display = 'block';
            if (inputHash === currentHash) {
                resultEl.className = 'compare-result match';
                resultEl.textContent = 'MATCH - Same device!';
            } else {
                resultEl.className = 'compare-result mismatch';
                resultEl.textContent = 'MISMATCH - Different device or error';
            }
        });
    </script>
</body>
</html>
